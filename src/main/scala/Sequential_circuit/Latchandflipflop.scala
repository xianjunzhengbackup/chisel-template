package Sequential_circuit

object Latchandflipflop extends App{
  /*
  SR Latch
  As a module to memorize the state, there are the following SR Latch. Since
  the output is connected to the input, it is hard to understand what kind of
  result will be. (The synthesis of combinational circuits of this type, in which
  the signal is looped, is prohibited in Chisel and Vivado. Therefore, we use a
  special procedure.)
  /** SR Latch
  */
  class SRLatch extends Module {
  val io = IO(new Bundle {
  val set = Input(Bool())
  val reset = Input(Bool())
  val q = Output(Bool())
  val notQ = Output(Bool())
  })
  io.q := ~(io.reset | io.notQ)
  io.notQ := ~(io.set | io.q)
  }
  What is the output of this module? Let's examine all cases of input and let's
  see what happens to the output.
  1. CASE: io.reset = true.B, io.set = false.B
  io.q is always false.B because io.reset is true.B.
  io.notQ is true.B because both io. set and io.q are false.B.
  2. CASE: io.reset = false.B, io.set = true.B
  Even if we apply the above conditions, io.q can not be determined
  because the value of io.notQ is unknown.
  Next, io.notQ is false.B because io.set is true.B.
  Let's investigate io.q again. Since both io.reset and io.notQ are false.B,
  io.q is true.
  3. CASE: io.reset = true.B, io.set = true.B
  io.q is false.B because io.reset is true.B.
  io.notQ is false.B because io.set is true.B.
  Both q and notQ have the same value, resulting in output inconsistent
  with the port name ...
  4. CASE: io.reset = false.B, io.set = false.B
  This case is complex.
  Even if the above conditions are applied, the value of io.notQ is
  unknown, so the value of io.q can not be determined.
  Since io.q is unknown, io.notQ can not be determined.
  However, assuming that the value of io.q is either, both values are
  determined.
  Assuming io.q was true.B, io.notQ will be false.B. If io.notQ is false.B,
  io.q will be true.B.
  Conversely, if io.q was false.B, io.notQ will be true.B. If io.notQ is
  true.B, io.q will be false.B.
  In other words, the result will change depending on what io.q was.
  In the past, if io.set = true.B and io.reset = false.B, then io.q was true.B.
  Even if the state of the circuit changes to io.reset = false.B, io.set =
  false.B, io.q holds the state of true.B.
  Conversely, if io.set = false.B and io.reset = true.B, then io.q was
  false.B. When transitioning from this state to this case, io.q keeps
  false.B.
  As mentioned above, the SR latch is a module with the ability to memorize
  past values when io.reset = false.B or io.set = false.B. The output when
  changing the input of the SR latch is as follows.
  SRLatch
  Let's run this module on the FPGA board.
  First of all, when outputting a Verilog file with Chisel, we need the option --
  no-check-comb-loops to not check the loop.
  sbt:sr-latch> runMain SRLatch --target-dir run_dir --no-check-
  comb-loops
  When synthesizing with Vivado, add a definition that allows looping to the
  constraint file. (Notice that we are using a button instead of a switch for
  input. The buttons printed as "BTNL", "BTNR" on the FPGA board are
  used.)
  ## LEDs
  set_property -dict { PACKAGE_PIN H17 IOSTANDARD LVCMOS33 }
  [get_ports { io_q }]; #IO_L18P_T2_A24_15 Sch=led[0]
  set_property -dict { PACKAGE_PIN K15 IOSTANDARD LVCMOS33 }
  io.out := RegEnable(io.in, 0.U(4.W), io.enable)
  }
  }
  The clock signal described in the previous section is automatically generated
  by Chisel. "reset" is also generated by Chisel. However, since the reset button
  of negative logic is used, the inverted signal of io.resetN is specified as the
  reset signal by using withReset as follows. If we treat other buttons (such as
  BTNU (M18)) as reset buttons, we can omit the "withReset ()" as follows.
  import chisel3._
  import chisel3.util._
  /** 4 bits Register
  */
  class Reg4Bit extends Module {
  val io = IO(new Bundle {
  val in = Input(UInt(4.W))
  val enable = Input(Bool())
  val out = Output(UInt(4.W))
  })
  io.out := RegEnable(io.in, 0.U(4.W), io.enable)
  }
  The constraint file in this case is as follows. Note that the definition of Clock
  Signal is "clock", not "io.clock" up to the previous section. (Compare with
  port declaration part of Verilog file)
  ## Clock signal
  set_property -dict { PACKAGE_PIN E3 IOSTANDARD LVCMOS33 }
  [get_ports { clock }]; #IO_L12P_T1_MRCC_35 Sch=clk100mhz
  create_clock -add -name sys_clk_pin -period 10.00 -waveform {0
  5} [get_ports {clock}];
  ##Switches
  set_property -dict { PACKAGE_PIN J15 IOSTANDARD LVCMOS33 }
  [get_ports { io_in[0] }]; #IO_L24N_T3_RS0_15 Sch=sw[0]
  set_property -dict { PACKAGE_PIN L16 IOSTANDARD LVCMOS33 }
  [get_ports { io_in[1] }]; #IO_L3N_T0_DQS_EMCCLK_14 Sch=sw[1]
  set_property -dict { PACKAGE_PIN M13 IOSTANDARD LVCMOS33 }
  [get_ports { io_in[2] }]; #IO_L6N_T0_D08_VREF_14 Sch=sw[2]
  set_property -dict { PACKAGE_PIN R15 IOSTANDARD LVCMOS33 }
  [get_ports { io_in[3] }]; #IO_L13N_T2_MRCC_14 Sch=sw[3]
  ## LEDs
  set_property -dict { PACKAGE_PIN H17 IOSTANDARD LVCMOS33 }
  [get_ports { io_out[0] }]; #IO_L18P_T2_A24_15 Sch=led[0]
  set_property -dict { PACKAGE_PIN K15 IOSTANDARD LVCMOS33 }
  [get_ports { io_out[1] }]; #IO_L24P_T3_RS1_15 Sch=led[1]
  set_property -dict { PACKAGE_PIN J13 IOSTANDARD LVCMOS33 }
  [get_ports { io_out[2] }]; #IO_L17N_T2_A25_15 Sch=led[2]
  set_property -dict { PACKAGE_PIN N14 IOSTANDARD LVCMOS33 }
  [get_ports { io_out[3] }]; #IO_L8P_T1_D11_14 Sch=led[3]
  ##Buttons
  set_property -dict { PACKAGE_PIN C12 IOSTANDARD LVCMOS33 }
  [get_ports { io_resetN }]; #IO_L3P_T0_DQS_AD1P_15
  Sch=cpu_resetn
  set_property -dict { PACKAGE_PIN N17 IOSTANDARD LVCMOS33 }
  [get_ports { io_enable }]; #IO_L9P_T1_DQS_14 Sch=btnc
  When treating BTNU (M18) as a reset button, comment out the io_resetN
  line and define as follows.
  set_property -dict { PACKAGE_PIN M18 IOSTANDARD LVCMOS33 }
  [get_ports { reset }]; #IO_L4N_T0_D05_14 Sch=btnu
  In the following explanation, it is assumed that the other buttons are for reset,
  not the CPU REST button.
   */

}
